---
title: "Microbenchmarking"
output: learnr::tutorial
runtime: shiny_prerendered
description: "Nous allons vous apprendre à utiliser Microbenchmark !"
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(microbenchmark)
knitr::opts_chunk$set(echo = FALSE)
```

## Bienvenue ! 

Cadeau, on se charge d'importer les librairies dont on aura besoin pour aujourd'hui à votre place.
Dans vos codes : pensez à library(microbenchmark) et library(GGplot2) !

### Ce qu'on fait aujourd'hui: 

L'objectif, c'est de comparer deux morceaux de codes qui produisent le même résultat pour savoir lequel est le plus rapide. Microbenchmarker : c'est exécuter chacune des opérations en boucle plusieurs fois de suite, et déterminer avec une moyenne des temps d'exécution le meilleur des codes qu'on a à disposition.

La bonne nouvelle en R, c'est que vous n'avez pas à le coder vous même ! Des gens brillant l'ont fait pour vous, et encore mieux : c'est simple d'utilisation et rapide !

Dans ce tuto, nous vous proposons deux séries d'exercices pour apprendre à comparer la vitesse de vos codes.

Dans la première, vous apprendrez le kit de survie dont vous aurez besoin pour optimiser vos programmes R, et abaisser les temps de calculs.

La seconde série rentre dans le détail des options. Elle intéressera ceux qui ont pour objectif de perfectionner leurs codes et gagner le plus de temps dans l'exécution de gros codes.

Alors, c'est parti ? 

## Kit de survie en milieu de complexité

### La syntaxe :

Dans la suite, nous utiliserons des requêtes du type : 

```{r syntaxelearnR, exercise=TRUE, exercise.lines = 1}

print(microbenchmark( "la/les fonction(s) à tester" )) 

```

car learnR ne permet pas l'affichage direct du résultat sans passer par print. Cette syntaxe est correcte en pratique dans R. 
Sachez cependant que, dans la console R, la syntaxe suivante fournit les mêmes résultats, et est plus simple : 

```{r syntaxeR, exercise=TRUE, exercise.lines = 1}
microbenchmark( "la/les fonction(s) à tester" )
```

### Exercice 1 : À vous d'essayer

Le bla-bla de présentation, c'est bien, mais il est désormais temps pour vous de passer à la pratique.

Essayez de calculer le temps nécessaire pour assigner une valeur à une variable (exemple : associer 10 à la variable x).

```{r exo1, exercise=TRUE, exercise.lines = 1 }
print( "Ton code" ) 
```

```{r exo1-solution, exercise.lines = 1}

print(microbenchmark(x <- 10))

```

Facile, non ? Il suffit de copier le morceau de code pour évaluer le temps de calcul. Sur ce genre d'opérations très (trop) simples, un message d'alerte peut être renvoyé. C'est normal, cela veut simplement dire que l'exécution est tellement rapide qu'on a du mal à évaluer son temps d'action.

Intéressons nous plutôt au résultat retourné. On voit qu'il y a l'unité de mesure, par défaut la nanoseconde. 
Le plus important pour nous, c'est la moyenne et le max. Pourquoi donc ? 
Parce que cela correspond respectivement à la complexité moyenne et la complexité au pire ! Selon ce que l'on code, l'un ou l'autre est plus intéressant (mais on ne va pas vous refaire les cours de Rémi Pépin !)

On s'intéressera aux autres colonnes dans la suite.

### Exercice 2 : L'exemple le plus important

Créez une séquence d'entiers allant de 1 à 1000 de 2 manières différentes, et évaluez la vitesse des deux méthodes.

  Astuce : les personnes ayant fait ce tuto ont trouvé au moins 3 manières différentes de créer la séquence demandée. Si c'est votre cas, n'hésitez pas à tester toutes les méthodes que vous avez réussi à coder.

```{r exo2, exercise=TRUE, exercice.lines = 3}



```

```{r exo2-solution,  exercice.lines = 3}

print(microbenchmark(c(1:1000), seq(1,1000),1:1000))

```


99 % du temps, ce simple exemple est ce dont on a besoin dans la vraie vie. Regardons donc les résultats dans le détail cette fois : 

On a les expressions, nommées "expr" et leurs résultats, rangés ligne par ligne. 

La colonne lq correspond au « low quartile ». C'est le 1er quartile des temps d’exécution de chaque expression. Cela se traduit par le fait qu'en pratique, au moins 25 % des tentatives ont mise ce temps au maximum.

uq, c'est le « upper quartile », même principe, mais avec le 3ème quartile.

Enfin, la colonne neval indique le nombre d'évaluations. C'est une donnée importante à prendre en compte, même si la gestion automatique est souvent très bonne de la part de Microbenchmark. Par défaut, le nombre d'évalutations réalisées par la fonction microbenchmark vaut 100.

La réponse devrait donc être facile à trouver : 

```{r quiz1}
question("Quelle est la meilleure fonction pour coder la matrice de la solution ?",
  answer("La première" , message = "Retente d'éxécuter la fonction ci dessus avec le code de la correction"),
  answer("La seconde", message = "Retente d'éxécuter la fonction ci dessus avec le code de la correction"),
  answer("La troisième", correct = TRUE, message = "Sur l'ensemble des aspects, cette solution est la plus rapide"),
  answer("c'est dur à dire", message = "On peut trancher dans cet exemple, regarde à nouveau les résultats avec l'explication au dessus)")
)
```

### Exercice 3 : Un autre (bon ?) exemple  !

Exprimez 3 fois 2 de différentes manières (eh oui, une multiplication, ca se décompose !), et comparez les temps de calcul.

```{r exo3, exercise=TRUE}



```

```{r exo3-solution}

print(microbenchmark(3*2, 2+2+2, 3+3))

#Plus long mais tout aussi correct :

print(microbenchmark(3*2))
print(microbenchmark(2+2+2))
print(microbenchmark(3*2))

```


```{r quiz}
question("Quelle est la meilleure des trois versions proposée dans la correction ?",
  answer("La première" , message = "effectivement, c'est parmis les deux meilleures options, mais en executant plusieurs fois le code, on ne peut pas dire si 3*2 et plus ou moins rapide que 3+3 en l'état. La partie suivante vous apprends à déterminer même dans ce cas là ;)"),
  answer("La seconde", message = "C'est l'option la moins intuitive, rendez vous dans la partie suivante pour comprendre pourquoi dans cet exemple, les résultats ne sont pas toujours exacts"),
  answer("La troisième", message = "effectivement, c'est parmis les deux meilleures options, mais en executant plusieurs fois le code, on ne peut pas dire si 3*2 et plus ou moins rapide que 3+3 en l'état. La partie suivante vous apprends à déterminer même dans ce cas là ;)"),
  answer("c'est dur à dire", correct = TRUE, message = "Oui, mais parfois on peut quand même trancher, rendez vous dans la partie suivante pour essayer !)")
)
```


## Techniques avancées

Cette fois-ci, ça ne rigole plus. On va comprendre pourquoi l'exemple d'avant n'a pas fonctionné. 

Le principal problème sur des morceaux de codes aussi rapides, c'est qu'il faut les exécuter un grand nombre de fois pour que ca marche. C'est le principe même du benchmarking. Les plus attentifs auront retenu que le nombre d'exécutions réalisées spontanément par microbenchmark était seulement de 100. (C'est le fameux neval de l'exercice 2).

Quand on y pense, c'est peu quand on effectue des mesures de l'ordre de la nanoseconde. Avec l'option times, vous pouvez tenter de déterminer un vainqueur même dans ce genre de situation en affinant les résultats.
(Attention, comme disait un grand penseur : "Même avec l'option times, des fois, ca marche, et des fois non".)

### Exercice 4 : L'exercice 3 était-il solvable ?

Reprenez le code de l'exercice 3, mais modifiez le nombre d'exécutions avec l'option times.

```{r exo4, exercise=TRUE, exercise.lines = 3 }



```

```{r exo4-hint, exercise.lines = 3}

#On met un L à la fin du nombre d'itérations (1000L par exemple)
#Ne me demandez pas pourquoi ... 
#Attention aux parenthèses, times est une option de microbenchmark, pas de print

```


```{r exo4-solution, exercise.lines = 1}

print(microbenchmark(3*2, 2+2+2, 3+3, times = 100000L))

```

```{r quiz2}

question("Y a t-il vraiment un code plus rapide entre 3*2 et 3+3 ?",
  answer("Oui" , message = "En réalité, peut-être, mais le concepteur de ce tutoriel a échoué à le montrer... pour l'instant. "),
  answer("Non", correct = TRUE, message = " Pour l'instant, c'est la réponse correcte, mais peut-être qu'une différence existe (très fine). Rendez vous à l'exercice 6 ")
)

``` 

Au-delà d'être un prétexte pour vous apprendre à changer le nombre d'itérations, cet exemple permet clairement d'éliminer 2+2+2 sans aucun doute.

### Exercice 5 : Sur plusieurs lignes ? 

Jusqu'ici, on a comparé des fonctions "simples". Voyons, maintenant que vous êtes aguerris, comment cela se passe dans un exemple réaliste.
Créez deux fonctions prenant en argument 2 nombres a et b, et cherchant le plus petit entier k compris entre 1 et 1000, tel que (k fois a) > b. Comparez ensuite ces fonctions entre elles.

```{r exo5, exercise=TRUE, exercise.lines = 15}



```

```{r exo5-hint, exercise.lines = 3}

#La première méthode qui vient à l'esprit est de réaliser une boucle while.
#La seconde possibilité est de créer un vecteur V contenant toutes les valeurs possibles de k, et de tester si la multiplication de chaque élément du vecteur par a est supérieure à b. Il ne reste plus alors qu'à sélectionner le premier élément V_i du vecteur tel que a*V_i > b soit évalué à TRUE.

```

```{r exo5-solution, exercise.lines = 15}

f1 <- function(a, b) {
  k <- 0
  while ((k*a <= b) && k <= 1000) {
    k <- k + 1
  }
  k
}

f2 <- function(a, b) {
  vector_k <- c(0:1000)
  k <- vector_k[(vector_k * a) > b][1]
  k
}

print(microbenchmark(f1, f2))
```

Preuve qu'on peut aussi faire du microbenchmark sans que la ligne de code soit illisible.

### Exercice 6 : "Jamais deux sans trois"

Nouvelle technique avancée : un graphique pour y voir plus clair.
Pour ca, on va utiliser GGplot2. 

Cette librairie possède une fonction nommée autoplot. Elle fait exactement ce que vous pensez : un graphe parfait sans que vous n'ayez quoi que ce soit à lui préciser. Si ca n'est pas clair ou que c'est une découverte : le premier indice est là pour vous !

Comparez graphiquement les temps d’exécution de 3 fois 2 et 3+3 avec autplot.

```{r exo6, message=FALSE, warning=FALSE, exercise=TRUE}



```

```{r exo6-hint, message=FALSE, warning=FALSE}

#?Autoplot donne ceci: autoplot(object, ...)
#object	: un objet, dont la classe determine le comportement de autoplot

```

```{r exo6-solution, message=FALSE, warning=FALSE}

res <- microbenchmark(3*2, 3+3, times = 10000L)
	    autoplot(res)


```

Les plus habiles cumuleront même cette technique avec celle du 4 et du 5 pour avoir de la précision et de la propreté ! Bravo à eux !

Le graphique est vraiment pratique et rapide à realiser, c'est une bonne solution (n'oubliez pas de remercier les auteurs de ce tuto pour cette astuce incroyable !).

### Exercice 7 : Les autres arguments, part 1

Microbenchmark possède des arguments que nous n'avons pas encore évoqués jusqu'ici.
Le premier auquel nous allons nous intéresser est : control.

C'est une liste d'aguments de... contrôle, dont le premier est "order" et ses valeurs sont : 
- random (l'option par défaut)
- inorder
- block

Cela agit sur l'ordre dans lequel microbenchmark effectue ses mesures. 
Respectivement :
- au hasard parmi les fonctions. 
- dans l'ordre (1-2-3, 1-2-3, ...).
- en block, chaque type à la suite (100 fois la première fonction, 100 fois la seconde, ...).

```{r exo7, message=FALSE, warning=FALSE, exercise=TRUE}



```

```{r exo7-hint, message=FALSE, warning=FALSE}

#La structure est celle-là : control est une liste d'arguments

print(microbenchmark(x <- 10, control = list( )))

```

```{r exo7-solution, message=FALSE, warning=FALSE}

print(microbenchmark(x <- 10, control = list( order = "random"  )))
print(microbenchmark(x <- 10, control = list( order = "inorder" )))
print(microbenchmark(x <- 10, control = list( order = "block"   )))

```


### Exercice 8 : Les autres arguments, part 2

Dans la famille des arguments de contrôle, je demande le numéro deux : warmup.

Il permet de déterminer combien d'évaluation "d'échauffement" seront faites avant de lancer les mesures. Par défaut, il vaut 2, mais on peut l'augmenter pour modéliser les situations d'exécution de code en continu.

Essayez de modifier microbenchmark(x <- 10) avec l'argument de control warmup. En le positionnant à 0 dans un premier exemple, puis à 10 dans un second.
Observez si l'augmentation d'évalutaions "dans le vide" réalisées avant le microbenchmarking impacte la valeur des temps d'exécution. 
 
```{r exo8, message=FALSE, warning=FALSE, exercise=TRUE}



```

```{r exo8-hint, message=FALSE, warning=FALSE}

#La structure est celle la : control est une liste d'arguments

print(microbenchmark(x <- 10, control = list( )))

```

```{r exo8-solution, message=FALSE, warning=FALSE}

print(microbenchmark(x <- 10, control = list(warmup =  0)))
print(microbenchmark(x <- 10, control = list(warmup = 10)))

```


```{r quiz3}

question(" Constatez vous une différence en utilisant un warmup? ?",
  answer("Oui" , correct = TRUE, message = " Effectivement, le maximum est quasiment toujours plus faible pour la version avec warmup. "),
  answer("Non", message = "En moyenne, vous auriez raison. Mais le maximum est quasiment toujours plus faible pour la version avec warmup. Retenez que la pire évaluation se fait quasiment toujours dans les premières évaluations du benchmarking (et qu'on peut vouloir la mesurer par ailleurs)")
) 

``` 
Les premières exécutions sont systématiquement plus lentes. 

### Exercice 9 :

### Exercice 10 : Les autres arguments, endgame

"Last but not least" comme diraient nos amis anglophones, voici le dernier argument de control : setup.

```{r exo10, message=FALSE, warning=FALSE, exercise=TRUE}



```

```{r exo10-hint, message=FALSE, warning=FALSE}

#La structure est celle la : control est une liste d'arguments

print(microbenchmark(x <- 10, control = list( )))

```

```{r exo10-solution, message=FALSE, warning=FALSE}



```


## Résumé

###
